####　哈希表的介绍
- 哈希表通常是基于数组进行实现的, 但是相对于数组, 它也有很多优势
 - 它可以提供非常快速的插入-删除-查找操作
 - 无论多少数据, 插入和删除值都是接近常量的时间, 即O(1)的时间复杂度, 实际上, 只需要几个机器指令即可完成
 - 哈希表的速度比树要快, 基本可以瞬间查找到想要的元素
- 哈希表相对于数组的一些不足
 - 哈希表中的数据是没有顺序的, 所以不能以一种固定的方式(比如从小到大)来遍历其中的元素(没有特殊处理情况下)
 - 通常情况下, 哈希表中的key是不允许重复的, 不能放置相同的key, 用于保存不同的值
 - ![avatar](./%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E7%94%9F%E6%88%90.png)

#### 案例一
 - ![avatar](./%E6%A1%88%E4%BE%8B%E4%B8%80.png)

#### 哈希表底层思想
- 将字符串转换成下标值(方案一)
  - ![avatar](./%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E7%94%9F%E6%88%90.png)
- 方案二
  - ![avatar](./%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E5%AD%97(%E4%BA%8C).png)
  - 下标的压缩算法
   - ![avatar](./%E4%B8%8B%E6%A0%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.png)

#### 哈希表的一些概念
 - 哈希化: 将大数字转换成数组范围下标的过程, 我们就称之为哈希化
 - 哈希函数: 通常我们会将单词转成大数字, 大数字在进行哈希化的代码实现放在一个函数中, 这个函数我们称为哈希函数
 - 哈希表: 最终将数据插入到这个数组, 对整个结构的封装, 我们就称为一个哈希表

#### 生成哈希表产生的冲突
 - ![avatar](./%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BA%A7%E7%94%9F%E7%9A%84%E5%86%B2%E7%AA%81.png)

#### 解决办法
 - 链地指法(也是用的最多的方法)
   - ![avatar](./%E9%93%BE%E5%9C%B0%E6%8C%87%E6%B3%95.png)

#### 哈希表的效率
 - 哈希表中执行插入和搜索操作效率是非常高的
   - 如果没有发生冲突, 那么效率就会更高
   - 如果发生冲突，存取时间就依赖后来的探测长度
   - 平均探测长度以及平均存取时间, 取决于填装因子, 随着填装因子变大, 探测长度也越来越长
   - 随着填装因子变大, 效率下降的情况, 在不同开放地址法方案中比链表法更严重, 所以我们来对比一下他们的效率, 在决定我们的方案
 - 填装因子
   - 填装因子表示当前哈希表中已经包含的数据项和 整个哈希表长度的比值
   - 填装因子 = 总数据项 / 哈希表长度
   - 开放地址法的装填因子最大是 1, 因为它必须找到空白的单元才能将元素放入
   - 链地址法的填装因子可以大于1, 因为拉链法可以无限的 延伸下去, 不过后面效率就会越来越低了

#### 哈希函数
 - 好的哈希函数应该使用少的乘法和除法, 因为他们的性能是比较低的
 - 哈希函数要具备哪些特点
   - 快速的计算
    - 哈希表的优势就在于效率, 所以快速获取到对应的hashCode非常重要
    - 我们需要通过快速的计算来获取到元素对应的hashCode
    - 霍纳法则
     - ![avatar](./%E9%9C%8D%E7%BA%B3%E6%B3%95%E5%88%99.png)
   - 均匀的分布
    - 哈希表中, 无论是链地址法还是开放地址法, 当多个元素映射到同一个位置的时候, 都会影响效率
    - 所以, 优秀的哈希函数应该尽可能将元素映射到不同的位置, 让元素在哈希表中均匀的分布
    - 使用常量的地方, 尽量使用质数
   - 质数的使用
    - 哈希表的长度
    - N次幂的底数(java中hashMap使用的是31)
  - 使用质数的原因
   - 质数和其他数相乘 的结果相比于其他数字更容易产生唯一性的结果, 减少哈希冲突
  
#### java中的hashMap底层原理
 - ![avatar](./java%E4%B8%ADhashMap%E7%9A%84%E5%8E%9F%E7%90%86.png)