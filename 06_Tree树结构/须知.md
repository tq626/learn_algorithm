#### 数据结构大比拼 
##### 数组
###### 优点
- 数组的主要优点是根据下标值访问效率会很高
- 但是如果我们希望根据元素来查找对应的位置,比较好的方式就是对数组先进行排序, 在进行二分查找
###### 缺点
- 需要先对数组进行排序, 生成有序数组, 才能提高查找效率
- 另外数组在插入和删除数组时, 需要大量的位移操作(插入到首位或者中间位置的时候), 效率很低

##### 链表
###### 优点
- 链表的插入和删除操作效率都很高
###### 缺点
- 查找效率很低, 需要从头开始依次访问链表中的每一个数据项, 直到找到
- 而且即使插入和删除操作效率很高, 但是如果要插入和删除中间位置的数据, 还是需要重头先找到对应的数据   

##### 哈希表
###### 优点
- 插入/查询/删除效率都是非常高
###### 缺点
- 空间利用率不高, 底层使用的是数组, 并且这些单元是没有被利用的
- 哈希表中的元素是无序的, 不能按照固定的顺序来遍历哈希表中的元素
- 不能快速的找出哈希表中最大值或者最小值这些特殊的值

##### 树
######　优点
 - 综合上面几种数据结构


#### 树的术语
- 1.节点的度(Degree): 节点的子树个数
- 2.树的度: 树的所有节点中最大的度数
- 3.叶节点(Left): 度为0的节点, (也称为叶子节点)
- 4.父节点(Parent): 有子树的节点是其子树的根节点的父节点
- 5.子节点:(Child): 若A节点是B节点的父节点, 则称B节点是A节点的子节点, 子节点也称孩子节点
- 6.兄弟节点(Sibling): 具有同一父节点的各节点彼此是兄弟节点
- 7.路径和长度: 从节点n1到nk的路径为一个节点序列n1, n2, ..., nk
 - ni是 n(i+1)的父节点
 - 路径所包含边的个数为路径的长度
- 8.节点的层次(Level): 规定根节点在1层，其他任一节点的层数是其父节点的层数加1
- 9.树的深度(Depth): 树中所有节点中的最大层次是这颗树的深度

#### 二叉树的概念
 - 如果树中每个节点最多只能有两个子节点, 这样的树就称为"二叉树"
   - 前面, 我们已经提过二叉树的重要性, 不仅仅是因为简单, 也因为几乎上所有的树都可以表示二叉树的形式
 - 二叉树的定义
  - 二叉树可以为空, 也就是没有节点
  - 若不为空, 则它是由根节点和称为其左子树TL和右子树TR的两个不相交二叉树组成的

##### 二叉树的特性
 - 一颗二叉树第i层的最大节点数为: 2^(i-1) i >= 1
 - 深度为k的二叉树的最大节点总数: 2^k - 1, k > = 1
 - 对于任何非空二叉树T, 若n0表示叶节点的个数, n2是深度为2的非 叶节点个数, 那么两者满足关系n0 = n2 +　１

##### 完美二叉树
 - 完美二叉树, 也称为满二叉树
  - 在二叉树中,除了最下一层的节点外, 每层节点都有2个子节点, 就构成了满二叉树

##### 完全二叉树
 - 完全二叉树
   - 除二叉树最后一层外, 其他各层的节点数都达到了最大个数
   - 且最后一层从左向右的节点连续存在, 只缺右侧若干节点
   - 完美二叉树是特殊的完全二叉树
   - ![avatar](./%E9%9D%9E%E5%AE%8C%E5%85%A8%E4%BA%8C%E8%8C%B6%E6%A0%91.png)

##### 二叉树的存储
 - 二叉树的存储常见方式是数组和链表
 - 数组存储方式![avatar](./%E4%BA%8C%E5%8F%89%E6%A0%91%E7%94%A8%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F.png)
 - 链表存储
   - 每一个节点封装成一个Node, node中包含存储的数据, 左节点的引用, 右节点的引用

#####　二叉搜索树
 - 二叉搜索树, 也称二叉排序树或二叉查找树
 - 二叉搜索树是一颗二叉树, 可以为空
 - 如果不为空, 满足以下性质
  - 非空左子树的所有键值小于其根节点的键值
  - 非空右子树的所有键值大于其根节点的键值
  - 左、右子树本身也都是二叉搜索树
 - 二叉搜索树的特点
   - 二叉搜索树的特点就是相对较小的值总是保存在左节点上, 相对较大的值总是保存在右节点上
   - 这一特点让其查找效率非常高, 这也是二叉搜索树中, 搜索的来源 

##### 二叉搜索树常见操作
- 插入操作
 - insert(value): 向树中插入一个新的数据
 - 插入解析:
   - 插入其他节点时, 我们需要判断该值到底是插入到左边还是插入到右边
   - 判断的依据来自于新节点的value和原来节点的value值比较
    - 如果新节点的newValue小于原节点的oldValue, 那么就向左边插入
    - 如果新节点的newValue大于原节点的oldValue，那么就向右边插入
   - 代码1序号位置, 就是准备向左子树插入数据,但是它本身又分为两种情况
    - 情况一: 左子树上原来没有内容, 那么直接插入
    - 情况二: 左子树上已经有了内容, 那么就依次向下继续查找新的走向, 所以使用递归调用即可
   - 代码2序号位置: 和1序号位置的逻辑差不多, 只是向右去查找
    - 情况一: 左右树上原来没有内容, 那么直接插入即可
    - 情况二: 右子树上已经有了内容, 那么就依次向下继续查找新的走向, 所以使用递归调用即可 
- 查找操作
  - search(value): 在树中查找一个数据, 如果节点存在, 则返回true, 如果不存在则返回false
  - min: 返回树中最小的值/数据
  - max: 返回树中最大的值/数据
- 遍历操作 (取决于访问根节点root的时机)
 - inOrderTraverse: 通过中序遍历方式遍历所有节点
  - 先访问左子树
  - 之后访问根节点
  - 之后访问右子树
  - 图解 ![avatar](./%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%9B%BE%E8%A7%A3.png)
 - preOrderTraverse: 通过先序遍历方式遍历所有的节点
  - 优先访问根节点
  - 之后开始访问左子树
  - 之后开始访问右子树
  - 图解: ![avatar](./%E4%BA%8C%E5%8F%89%E6%A0%91%E7%94%A8%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F.png)
 - postOrderTraverse: 通过后序遍历方式遍历所有的节点
  - 先访问左子节点
  - 之后访问右子节点
  - 最后访问根节点
  - 图解 ![avatar](./%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86.png)
 - levelOrderTraverse: 通过层序遍历方式遍历所有的节点
  - 图解 ![avatar](./%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%9B%BE%E8%A7%A3.png)
- 删除操作
  - remove(value): 从树中移除某个数据
   - 情况一: 两个子节点(情况最为复杂)
    - ![avatar](./%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9(%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%83%85%E5%86%B5).png)
    - 前驱和后继节点的寻找
     - ![avatar](./%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E5%AF%BB%E6%89%BE%E5%89%8D%E9%A9%B1%E5%92%8C%E5%90%8E%E7%BB%A7%E8%AE%B2%E8%A7%A3.png)